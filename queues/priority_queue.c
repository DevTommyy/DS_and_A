#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>

#define SIZE 1024

struct PriorityQueue {
    int elements[SIZE];
    size_t current;
    // the head and the tail of this priority queue
    // are index `0` and index `current`
} typedef PriorityQueue;

void max_heapify(PriorityQueue* queue);
void swap(PriorityQueue* queue, int child_idx, int parent_idx);

void enqueue(PriorityQueue* queue, int val);
int dequeue(PriorityQueue* queue);

int peek(PriorityQueue* queue);

void print(PriorityQueue* queue);

// Reorder the `PriorityQueue` in a increasing manner.
/// This takes `O(log n)` time
void max_heapify(PriorityQueue* queue) {
    int idx = queue->current - 1;
    // (idx -1) / 2] is the parent idx
    while (idx > 0 && queue->elements[idx] > queue->elements[(idx - 1) / 2]) {
        swap(queue, idx, (idx -1) / 2);
        idx = (idx -1) / 2;
    }
}

/// Swaps a child and its parent on the priority queue given their indexes.
/// This takes `O(1)` time
///
/// # Params
/// 
/// - `heap` the `PriorityQueue*` we are referring to
/// - `child_idx` the index of the child to swap
/// - `parent_idx` the index of the parent to swap
void swap(PriorityQueue* queue, int child_idx, int parent_idx) {
    int tmp = queue->elements[child_idx];
    queue->elements[child_idx] = queue->elements[parent_idx];
    queue->elements[parent_idx] = tmp;
}

// just like adding an element in the heap
/// Enqueues an new value in the `PriorityQueue`.
/// This is a `O(log n)` operation
///
/// # Params
/// 
/// - `queue` the `PriorityQueue` we are referring to
/// - `val` an `int` representing the value to enqueue
void enqueue(PriorityQueue* queue, int val) {
    if (queue->current + 1 == SIZE) {
        printf( 
            "Couldn't add anymore elemets, the length \
             of the queue exceeds the maximum size %d",
            SIZE
         );
         return;
    } else {
        queue->elements[queue->current] = val;
        queue->current++;
        max_heapify(queue);
    }
}

/// Dequeues a value from the `PriorityQueue` and return it's value
/// This is a `O(log n)` operation
///
/// # Params
/// 
/// - `queue` the `PriorityQueue` we are referring to
/// - `val` an `int` representing the value to enqueue
///
/// # Returns
/// 
/// - `0` if the queue is empty
/// - `val` the value of the element dequeued if the queue is not empty
int dequeue(PriorityQueue* queue) {
    // the queue is empty
    if (queue->current == 0) {
        return 0;
    }
    // get the value of the first element
    int idx = 0;
    int val = queue->elements[idx];

    // decrease the queue length
    queue->current--;
    queue->elements[idx] = queue->elements[queue->current];

    // reset or free it
    queue->elements[queue->current] = 0;

    // save its children indexes
    int left = (2 * idx) + 1;
    int right = (2 * idx) + 2;
    
    // this loops while the property of the underlying heap is not satisfied.
    // swaps the elements if one of the children of the inspected element
    // (idx) is bigger.
    while (left < queue->current && right < queue->current &&
        ((queue->elements[idx] < queue->elements[left]) ||
        (queue->elements[idx] < queue->elements[right]))
    ) {
        if (queue->elements[left] > queue->elements[right]) {// the left one is the bigger one
            swap(queue, left, idx);
            idx = left;
            left = (2 * idx) + 1;
            right = (2 * idx) + 2;
        } else { // the right one is the bigger one
            swap(queue, right, idx);
            idx = right;
            left = (2 * idx) + 1;
            right = (2 * idx) + 2;
        }
    }
    return val;
}

/// Peeks into the `PriorityQueue` to retrive the first value.
/// This is an `O(1)` time operation
///
/// # Params
///
/// - `queue` the `PriorityQueue` to peek into
///
/// # Returns 
///
/// - `0` if the queue is empty
/// - `val` the value of the element peeked if the queue is not empty
int peek(PriorityQueue* queue) {
    // the queue is empty
    if (queue->current == 0) {
        return 0;
    }
    return queue->elements[0];
}

void print(PriorityQueue* queue) {
    printf("[ ");
    for (size_t i = 0; i < queue->current; i++) { 
        printf("%d ", queue->elements[i]);
    }
    printf("]\n");
}

// some random testing generated by chatGPT
int main() {
    // Allocate memory for the priority queue
    PriorityQueue* queue = (PriorityQueue*)malloc(sizeof(PriorityQueue));
    // Initialize the priority queue
    queue->current = 0;

    // Test enqueue
    enqueue(queue, 10);
    enqueue(queue, 5);
    enqueue(queue, 20);
    enqueue(queue, 15);

    // Print the queue
    printf("Queue after enqueuing: ");
    print(queue);

    // Test dequeue
    int dequeued = dequeue(queue);
    printf("Dequeued element: %d\n", dequeued);

    // Print the queue after dequeue
    printf("Queue after dequeue: ");
    print(queue);

    // Test dequeue
    dequeued = dequeue(queue);
    printf("Dequeued element: %d\n", dequeued);

    // Print the queue after dequeue
    printf("Queue after dequeue: ");
    print(queue);

    // Test peek
    int front = peek(queue);
    printf("Front element: %d\n", front);

    // Free the memory allocated for the priority queue
    free(queue);

    return 0;
}