#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>

#include "../headers/Deque.h"

#define MAX(a,b) ((a) > (b) ? (a) : (b))

struct Node {
    int val;
    struct Node* left;
    struct Node* right;
    int height;
} typedef Node;

struct Tree {
    Node* root;
    int len;
} typedef Tree;

int get_height(Node* node);
int get_balance(Node* node);
Node* get(Node* current, int val);
Node* getParent(Node* current, int val);

void left_rotation(Node** root);
void right_rotation(Node** root);
void check_balance(Node** current);

/* 
 * Most of those implementation are the same as
 * for a normal binary tree, apart for something
 * on the insert logic but mostly the delete
 * changes a bit, the others i think remain the same
 */
void insert(Tree* tree, int val);
void insertNode(Node** current, Node* node);

bool contains(Node* current, int val);
Node* get(Node* current, int val);
Node* getParent(Node* current, int val);

bool compare(Node* self, Node* other);

bool delete(Tree* tree, int val);
// a stack (in this case a deque implementation) is needed for this

void printInorder(Node* node);
void freeAll(Node* node);

int get_height(Node* node) {
    if(node == NULL) {
        return 0;
    }
    return node->height;
}

int get_balance(Node* node) {
    if (node == NULL) {
        return 0;
    }
    // calculate balance factor
    return get_height(node->left) - get_height(node->right);
}

/// gets a node from the tree given it's value
///  
/// # Returns
/// A `NULL` pointer if the node isn't found
/// A `Node` pointer if the value is found 
Node* get(Node* current, int val) {
    if (current == NULL) {
        return NULL;
    } else {
        if (val == current->val) {
            return current;
        } else if (val < current->val) {
            return get(current->left, val);
        } else {
            return get(current->right, val);
        }
        return NULL;
    }
}

/// gets the parent of a node given the child value
/// 
/// # Returns
/// A `NULL` pointer if the parent node isn't found
/// A `Node` pointer if the parent node is found 
Node* getParent(Node* current, int val) {
    if (current == NULL || current->val == val) {
        // No parent or the node itself is the root
        return NULL; 
    }

    if ((current->left != NULL && current->left->val == val) ||
        (current->right != NULL && current->right->val == val)) {
        // Found the parent of the node
        return current; 
    }

    // Recursively search in left and right subtrees
    if (val < current->val) {
        return getParent(current->left, val);
    } else {
        return getParent(current->right, val);
    }
}

void left_rotation(Node** root) {
    if(*root == NULL || (*root)->right == NULL)  return;

    Node* right_node = (*root)->right;
    (*root)->right = right_node->left;
    right_node->left = *root;
    *root = right_node;

    // update the new heights
    right_node->left->height = MAX(get_height(right_node->left->left), get_height(right_node->left->right)) + 1;
    right_node->height = MAX(get_height(right_node->left), get_height(right_node->right)) + 1;
}

void right_rotation(Node** root) {
    if(*root == NULL || (*root)->left == NULL)  return;

    Node* left_node = (*root)->left;
    (*root)->left = left_node->right;
    left_node->right = *root;
    *root = left_node;

    // update the new heights
    left_node->right->height = MAX(get_height(left_node->right->left), get_height(left_node->right->right)) + 1;
    left_node->height = MAX(get_height(left_node->left), get_height(left_node->right)) + 1;
}

void check_balance(Node** current) {
    int balance = get_balance(*current);
    printf("current: %d, balance, %d\n", (*current)->val, balance);
    // Perform rotations if necessary
    if (balance > 1) {
        if (get_balance((*current)->left) >= 0) {
            printf("right rotation\n");
            right_rotation(current);
        } else {
            printf("left and right rotation\n");
            left_rotation(&((*current)->left));
            right_rotation(current);
        }
    } else if (balance < -1) {
        if (get_balance((*current)->right) <= 0) {
            printf("left rotation\n");
            left_rotation(current);
        } else {
            printf("right and left rotation\n");
            right_rotation(&((*current)->right));
            left_rotation(current);
        }
    }
    // Update heights after rotations
    (*current)->height = MAX(get_height((*current)->left), get_height((*current)->right)) + 1;
}
/// inserts a node into the tree if its the root
/// or calls an helper function to insert it
/// 
/// # Params
///
/// `tree` the `Tree` in which to insert
/// `val` an int representing the value to insert
void insert(Tree* tree, int val) {
    tree->len++;

    // initialize new node
    Node* node = malloc(sizeof(Node));
    node->val = val;
    node->left = NULL;
    node->right = NULL;
    node->height = 1;

    if (tree->root == NULL) {
        tree->root = node;
    } else {
        insertNode(&(tree->root), node);
    }
}

/// inserts a node into the tree
/// 
/// # Params
///
/// `current` the root of the `Tree`
/// `val` an int representing the value to insert
void insertNode(Node** current, Node* node) {
    if (node->val < (*current)->val) {
        // inserting in the left
        if ((*current)->left == NULL) {
            (*current)->left = node;
        } else {
            insertNode(&((*current)->left), node);
        }
    } else {
        // inserting in the right
        if ((*current)->right == NULL) {
            (*current)->right = node;
        } else {
            insertNode(&((*current)->right), node);
        }
    }

    // Update heights before checking balance
    (*current)->height = MAX(get_height((*current)->left), get_height((*current)->right)) + 1;
    check_balance(current);
    printf("check balance returned, now the tree is: \n");
    printInorder(*current);
    printf("\n");
}

bool delete(Tree* tree, int val) {
    Node* to_remove = get(tree->root, val);
    if (tree->len == 0 || to_remove == NULL) {
        return false;
    } else {
        Node* parent = NULL;
        Deque *path = (Deque *)malloc(sizeof(Deque));
        path->head = NULL;
        path->tail = NULL;
        
        Node* current = tree->root;
        while (current != NULL) {
            enqueue_front(path, current->val);
            if (val == current->val) {
                to_remove = current;
                break;
            } else if (val < current->val) {
                parent = current;
                current = current->left;
            } else {
                parent = current;
                current = current->right;
            }
        }
        if (tree->len == 1) {
            tree->root = NULL;
        } else if (to_remove->left == NULL && to_remove->right == NULL) {
            if (to_remove->val < parent->val) {
                parent->left = NULL;
            } else {
                parent->right = NULL;
            }
        } else if (to_remove->left == NULL && to_remove->right != NULL) {
            if (to_remove->val < parent->val) {
                parent->left = to_remove->right;
            } else {
                parent->right = to_remove->right;
            }
        } else if (to_remove->left != NULL && to_remove->right == NULL) {
            if (to_remove->val < parent->val) {
                parent->left = to_remove->left;
            } else {
                parent->right = to_remove->left;
            }
        } else {
            Node* largest_parent = to_remove;
            Node* largest = to_remove->left;
            while (largest->right != NULL) {
                largest_parent = largest;
                largest = largest->right;
            }
            if (largest_parent == to_remove) {
                to_remove->left = largest->left;
            } else {
                largest_parent->right = largest->left;
            }
            to_remove->val = largest->val;
            if (largest->left != NULL) {
                getParent(tree->root, largest->val)->right = largest->left;
            }
            // Update heights and balance of nodes in the path from root to largest node
            while (largest != to_remove) {
                largest = getParent(tree->root, largest->val);
                largest->height = MAX(get_height(largest->left), get_height(largest->right)) + 1;
                check_balance(&largest);
            }
        }
        while(path->head != NULL) {
            Node* to_check = get(tree->root, dequeue_front(path));
            if (to_check == NULL) {
                continue;
            }
            check_balance(&to_check);
            // Update parent pointers after rotations
            if (to_check->left != NULL) {
                getParent(tree->root, to_check->left->val)->left = to_check->left;
            }
            if (to_check->right != NULL) {
                getParent(tree->root, to_check->right->val)->right = to_check->right;
            }
        }
        tree->len--;
        return true;
    }
}


// =============================== UTILS ======================
/// prints the tree in orders based on where you put the print
void printInorder(Node* node) {
    if (node != NULL) {
        printf("%d ", node->val); // if print is there, from start to end (preorder)
        printInorder(node->left); // if print is there root is in the centre (inorder)
        printInorder(node->right); // if print is there from end to start (postorder)
        // as the comments say the order should be what is in the parentheses but inorder
        // is actually like this
    }
}

/// frees all the memory allocated by the list
void freeAll(Node* node) {
    if (node != NULL) {
        freeAll(node->left);
        freeAll(node->right);
        free(node);
    }
}